<!doctype html>
<html>
<head>
  <title>Client</title>
</head>
<body>

  <h1>Secret number guessing game</h1>
  <div id="proverDiv" style="padding-bottom: 10px">
    <p>First choose your secret:</p>
    <input type="number" id="setSecret">
    <button id="begin">Start game</button>
    <br>
  </div>
  <div id="verifier" style="display:none">
    <button id="CloseToButton"> Close to </button>
    <button id="MoreLessButton"> More or Less </button>
    <button id="GuessButton"> Make a guess </button>
    <input type="number" id="value1">

    <!-- JS-generated output will be added here. -->
    <pre class="proof"> Proof: <code id="proof"></code></pre>

    <pre class="proof"> Proof valid: <code id="result"></code></pre>
    <pre class="proof"> Result: <code id="feedback"></p></pre>
  </div>
  


  <script src="snarkjs.min.js"> </script>


  <!-- This is the bundle generated by rollup.js -->
  <script>

const proofComponent = document.getElementById('proof');
const resultComponent = document.getElementById('result');
const CloseToButton = document.getElementById("CloseToButton");
const GuessButton = document.getElementById("GuessButton");
const startButton = document.getElementById("begin");
const verifierDiv = document.getElementById("verifier");
const proverDiv = document.getElementById("proverDiv");
const feedback = document.getElementById("feedback");

CloseToButton.addEventListener("click", calculateProofClose);
GuessButton.addEventListener("click", calculateProofGuess);
MoreLessButton.addEventListener("click", calculateProofMoreLess);
startButton.addEventListener("click", showVerifier);

function showVerifier() {
  verifierDiv.style.display = "block";
  proverDiv.style.display = "none";
}

async function calculateProofClose() {

    const challenge = parseInt(value1.value);
    const secret = parseInt(setSecret.value);

    const { proof, publicSignals } =
      await snarkjs.groth16.fullProve( {secret: secret, challenge: challenge}, "Close_to.wasm", "close_to.zkey");

    proofComponent.innerHTML = JSON.stringify(publicSignals);
    if (publicSignals[1] == 1) {
      feedback.innerHTML = "yes, you are close!";
    }
    else {
      feedback.innerHTML = "not even close, try again!";
    }
    


    const vkey = await fetch("verification_key_closeto.json").then( function(res) {
        return res.json();
    });
    const res = await snarkjs.groth16.verify(vkey, publicSignals, proof);

    resultComponent.innerHTML = res;
}

async function calculateProofGuess() {

const challenge = parseInt(value1.value);
const secret = parseInt(setSecret.value);

const { proof, publicSignals } =
  await snarkjs.groth16.fullProve( {secret: secret, challenge: challenge}, "guess.wasm", "guess.zkey");

proofComponent.innerHTML = JSON.stringify(publicSignals);
if (publicSignals[1] == 1) {
      feedback.innerHTML = "Correct, well played!";
    }
    else {
      feedback.innerHTML = "That is not the secret number :/";
    }

const vkey = await fetch("verification_key_guess.json").then( function(res) {
    return res.json();
});
const res = await snarkjs.groth16.verify(vkey, publicSignals, proof);

resultComponent.innerHTML = res;
}

async function calculateProofMoreLess() {

const challenge = parseInt(value1.value);
const secret = parseInt(setSecret.value);

const { proof, publicSignals } =
  await snarkjs.groth16.fullProve( {secret: secret, challenge: challenge}, "MoreLess.wasm", "MoreLess.zkey");

proofComponent.innerHTML = JSON.stringify(publicSignals);


const vkey = await fetch("verification_key_MoreLess.json").then( function(res) {
    return res.json();
});
const res = await snarkjs.groth16.verify(vkey, publicSignals, proof);

resultComponent.innerHTML = res;
}

  </script>

</body>
</html>